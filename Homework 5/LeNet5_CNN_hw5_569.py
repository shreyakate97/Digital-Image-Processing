# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18PLlDVjwTlFIIIvF_iW_sCtPue_dW9sw
"""

# !pip install http://download.pytorch.org/whl/cu92/torch-0.4.1-cp36-cp36m-linux_x86_64.whl
# !pip install torchvision

import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F


# I used this for using the gpu in google colab
######################################################################
import numpy as np
import torch as th
seed = 42
np.random.seed(seed)
torch.manual_seed(seed)

if th.cuda.is_available():
  th.backends.cudnn.deterministic = True
  th.cuda.manual_seed(seed)

device = th.device("cuda" if th.cuda.is_available() else "cpu")
#####################################################################
transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize(mean=(0.5, 0.5, 0.5), std=(0.5, 0.5, 0.5))]) # normalize to make range [-1,1]
train_batch_size = 64
test_batch_size = 1000
train_set = torchvision.datasets.CIFAR10(root='./data', train=True,
                                        download=True, transform=transform)

train_loader = torch.utils.data.DataLoader(train_set, batch_size=train_batch_size, shuffle=True,
                                          num_workers=2)

test_set = torchvision.datasets.CIFAR10(root='./data', train=False,
                                       download=True, transform=transform)
test_loader = torch.utils.data.DataLoader(test_set, batch_size=test_batch_size, shuffle=True,
                                         num_workers=2)
classes = ('plane', 'car', 'bird', 'cat',
           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')

"""CNN"""

class myCNN(nn.Module):
    def __init__(self):
        super(myCNN, self).__init__()

        self.conv1 = nn.Conv2d(3,18,5, stride=1, padding=0)
        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)
        self.conv2 = nn.Conv2d(18,48,5, stride=1, padding=0)
        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)

        self.fc1 = nn.Linear(48*5*5, 120)
        self.fc2 = nn.Linear(120, 84)
        self.fc3 = nn.Linear(84,10)
    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool1(x)
        x = F.relu(self.conv2(x))
        x = self.pool2(x)

        x = x.view(-1, 48*5*5)

        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        #output layer uses softmax activation function
        x = self.fc3(x)
        return x

"""Loss function and optimizer"""

import torch.optim as optim

def Loss_Function_Optimizer(myCNN, learning_rate):
        criterion_f = nn.CrossEntropyLoss()
        optimizer = optim.SGD(myCNN.parameters(), lr = learning_rate, momentum=0.9)
        return criterion_f,optimizer

"""Accuracy"""

def accuracy(data_loader,c):

          positive = 0
          total = 0
          for i, (images, classes) in enumerate(data_loader):
            images, classes = images.to(device),classes.to(device)
            outputs = c(images)
            _, predicted = torch.max(outputs, 1)
            total += classes.size(0)

            positive += (predicted == classes).sum().item()
          return positive/total

"""Training"""

def train(c, learning_rate, number_of_epochs, batch_size):

    number_of_batches = len(train_loader)
    criterion_f, optimizer = Loss_Function_Optimizer(c, learning_rate)
    c = c.to(device)
    training_acc = []
    testing_acc = []
    for epoch in range(number_of_epochs):
        r_loss = 0

        for i, (images, classes) in enumerate(train_loader):
            images, classes = images.to(device),classes.to(device)
            optimizer.zero_grad()

            out_vector = c(images)
            l = criterion_f(out_vector,classes)
            l.backward()
            optimizer.step()

            r_loss += l.item()

        if i % 100 == 99:
            print('[%d,%5d] loss: %.3f' % (epoch+1,i+1,r_loss/100))
            r_loss = 0

        acc_train = accuracy(train_loader,c)
        acc_test = accuracy(test_loader,c)
        training_acc.append(acc_train)
        testing_acc.append(acc_test)
        print('\n', epoch, acc_train,acc_test)
    print('finished training')
    return training_acc,testing_acc

x = myCNN()

training_acc,testing_acc = train(x,0.001,30,32)

"""Epoch vs training accuracy (red)
Epoch vs testing accuracy (green)

both in same graph
"""

import matplotlib.pyplot as plt
plt.plot(np.arange(1,31,1),training_acc,'r',label='training')
plt.plot(np.arange(1,31,1),testing_acc,'g',label='testing')
plt.grid(True)
plt.xticks(np.arange(0,31,2))
plt.yticks(np.arange(0,1.1,0.1))
plt.xlabel('Number of epochs')
plt.ylabel('Accuracy')
fig = plt.gcf()
fig.set_size_inches(10,8)
fig.savefig('m_1.png', dpi=100)
plt.legend()

plt.show()
